import React, { useState, useEffect } from 'react';
import { pipeline } from '@xenova/transformers';

// Dot-product cosine similarity
function cosineSimilarity(a, b) {
  const dot = a.reduce((sum, ai, i) => sum + ai * b[i], 0);
  const magA = Math.sqrt(a.reduce((sum, ai) => sum + ai * ai, 0));
  const magB = Math.sqrt(b.reduce((sum, bi) => sum + bi * bi, 0));
  return dot / (magA * magB);
}

// Average a 2D array of token embeddings into one vector
function averageTokens(tokens2d) {
  const dim = tokens2d[0].length;
  const sum = new Array(dim).fill(0);
  tokens2d.forEach(tok => tok.forEach((v, i) => (sum[i] += v)));
  return sum.map(v => v / tokens2d.length);
}

/**
 * Normalize pipeline output into a flat [dim] JS array.
 * Supports:
 *  - JS nested arrays: [ [tokenVec,‚Ä¶], ‚Ä¶ ]
 *  - Transformers.js Tensor-like objects with .data and .dims
 */
function getEmbeddingVector(out) {
  // Case 1: JS nested arrays
  if (Array.isArray(out)) {
    const batch = out;
    if (!Array.isArray(batch[0])) {
      throw new Error('Expected nested array but got flat array');
    }
    const first = batch[0];
    // first may be [tokenVec,...] or already pooled vector
    if (Array.isArray(first[0])) {
      return averageTokens(first);
    } else {
      return first;
    }
  }

  // Case 2: Transformers.js tensor proxy with .data and .dims
  if (out.data && Array.isArray(out.dims)) {
    const { data, dims } = out;
    // dims: [batch, seqLen, dim]
    if (dims.length === 3) {
      const [, seqLen, dim] = dims;
      const tokens = [];
      for (let i = 0; i < seqLen; i++) {
        const start = i * dim;
        tokens.push(Array.from(data.slice(start, start + dim)));
      }
      return averageTokens(tokens);
    }
    // dims: [batch, dim] => pool across batch
    if (dims.length === 2) {
      const [batch, dim] = dims;
      const sum = new Array(dim).fill(0);
      for (let b = 0; b < batch; b++) {
        for (let j = 0; j < dim; j++) {
          sum[j] += data[b * dim + j];
        }
      }
      return sum.map(v => v / batch);
    }
    throw new Error(`Unsupported tensor dims length ${dims.length}`);
  }

  throw new Error('Unsupported pipeline output format');
}

export default function App() {
  const [model, setModel] = useState(null);
  const [loadingModel, setLoadingModel] = useState(true);
  const [error, setError] = useState(null);

  const [userText, setUserText] = useState('');
  const [expectedText, setExpectedText] = useState('');
  const [loading, setLoading] = useState(false);
  const [similarity, setSimilarity] = useState(null);

  // Load the in-browser embedding model
  useEffect(() => {
    console.log('‚ñ∂Ô∏è Loading model‚Ä¶');
    pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2')
      .then(pipe => {
        console.log('‚úÖ Model ready');
        setModel(() => pipe);
      })
      .catch(err => {
        console.error('‚ùå Model load failed', err);
        setError('Model load failed: ' + err.message);
      })
      .finally(() => setLoadingModel(false));
  }, []);

  // Compare the two text inputs
  const compareTexts = async () => {
    if (!model) return;
    setLoading(true);
    setError(null);
    setSimilarity(null);

    console.log('‚ñ∂Ô∏è Comparing:', { userText, expectedText });
    try {
      const [out1, out2] = await Promise.all([
        model(userText),
        model(expectedText),
      ]);
      console.log('üßÆ Raw outputs:', out1, out2);

      const vec1 = getEmbeddingVector(out1);
      const vec2 = getEmbeddingVector(out2);
      console.log('‚öôÔ∏è Vectors lengths:', vec1.length, vec2.length);

      const sim = cosineSimilarity(vec1, vec2);
      console.log('üìä Similarity:', sim);
      setSimilarity(sim);
    } catch (err) {
      console.error('‚ùå Embedding error', err);
      setError('Error generating embeddings: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="p-6 font-sans max-w-lg mx-auto">
      <h1 className="text-2xl font-bold mb-4">Embedding Comparison</h1>

      {error && (
        <div className="mb-4 p-2 bg-red-100 text-red-700 border border-red-300">
          {error}
        </div>
      )}

      <label className="block font-semibold mb-1">User Input</label>
      <textarea
        value={userText}
        onChange={e => setUserText(e.target.value)}
        className="w-full border p-2 mb-4"
        rows={3}
        placeholder="Enter your text here"
      />

      <label className="block font-semibold mb-1">Expected Text</label>
      <textarea
        value={expectedText}
        onChange={e => setExpectedText(e.target.value)}
        className="w-full border p-2 mb-4"
        rows={3}
        placeholder="Enter the expected text here"
      />

      <button
        onClick={compareTexts}
        disabled={
          loadingModel ||
          loading ||
          !userText.trim() ||
          !expectedText.trim()
        }
        className="bg-blue-600 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        {loadingModel
          ? 'Loading model...'
          : loading
          ? 'Comparing...'
          : 'Compare Similarity'}
      </button>

      {similarity !== null && (
        <div className="mt-6 text-lg">
          Similarity:&nbsp;
          <span className="font-bold">{similarity.toFixed(4)}</span>
        </div>
      )}
    </div>
  );
}
